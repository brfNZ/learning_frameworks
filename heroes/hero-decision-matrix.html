<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Simplified Hero Decision Matrix</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <style>
        .hero-icon {
            width: 32px;
            height: 32px;
            fill: none;
            stroke: currentColor;
            stroke-width: 2;
            stroke-linecap: round;
            stroke-linejoin: round;
        }
        .small-icon {
            width: 20px;
            height: 20px;
            fill: none;
            stroke: currentColor;
            stroke-width: 2;
            stroke-linecap: round;
            stroke-linejoin: round;
        }
        .rating-container {
            display: flex;
            justify-content: center;
            gap: 8px;
            align-items: flex-start;
        }
        .rating-group {
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 80px;
        }
        .rating-btn {
            width: 40px;
            height: 40px;
            padding: 0;
            border-radius: 50%;
            transition: all 0.3s;
            font-size: 14px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .rating-label {
            text-align: center;
            min-width: 80px;
            font-size: 12px;
            margin-top: 4px;
            white-space: nowrap;
        }
        html, body {
            scroll-behavior: smooth;
        }
        .sticky {
            position: sticky;
        }
        .rating-btn.selected {
            background-color: #2563eb;
            border-color: #2563eb;
            color: #ffffff;
        }
    </style>
</head>
<body class="bg-gray-50 min-h-screen">
    <div id="app"></div>

    <script>
        // State management
        let state = {
            decision: '',
            options: ['', ''],
            currentStep: 0,
            responses: {},
            showResults: false,
            selectedQuestions: [],
            skipped: new Set()
        };

        // Heroes configuration with all questions
        const heroesQuestions = {
            spiritual: {
                name: "Spiritual Wisdom",
                color: "bg-purple-100 border-purple-300 text-purple-800",
                core: "What does my inner wisdom say about each option?",
                questions: [
                    "Which option comes from love rather than fear?",
                    "Which option brings the greatest peace and light?",
                    "What would I choose if I were completely unattached to the outcome?"
                ],
                focus: "Divine guidance and intuition"
            },
            socrates: {
                name: "Socrates",
                color: "bg-blue-100 border-blue-300 text-blue-800",
                core: "What assumptions am I making that I haven't examined?",
                questions: [
                    "What would happen if I'm completely wrong about this?",
                    "What do I truly know vs. what do I think I know?",
                    "What questions should I be asking that I'm not?"
                ],
                focus: "Questioning assumptions and seeking truth"
            },
            aristotle: {
                name: "Aristotle",
                color: "bg-orange-100 border-orange-300 text-orange-800",
                core: "What are the logical consequences of each option?",
                questions: [
                    "Which choice leads to the most flourishing (eudaimonia)?",
                    "What would the virtuous person do in this situation?",
                    "Which option represents the golden mean between extremes?"
                ],
                focus: "Logical analysis and virtue"
            },
            aynRand: {
                name: "Ayn Rand",
                color: "bg-green-100 border-green-300 text-green-800",
                core: "Which option best serves my rational self-interest?",
                questions: [
                    "Am I making this choice based on my own judgment or others' expectations?",
                    "Which option creates the most genuine value?",
                    "Does this align with my core principles and values?"
                ],
                focus: "Independent rational judgment"
            }
        };

        // Helper functions
        function addOption() {
            if (state.options.length < 5) {
                state.options.push('');
                render();
            }
        }

        function removeOption(index) {
            if (state.options.length > 2) {
                state.options.splice(index, 1);
                Object.keys(state.responses).forEach(key => {
                    const [, oIdx] = key.split('-').map(Number);
                    if (oIdx === index) {
                        delete state.responses[key];
                    } else if (oIdx > index) {
                        const [qIdx] = key.split('-').map(Number);
                        delete state.responses[key];
                        state.responses[`${qIdx}-${oIdx - 1}`] = state.responses[key];
                    }
                });
                render();
            }
        }

        function updateOption(index, value) {
            state.options[index] = value;
        }

        function generateQuestions() {
            const questions = [];
            const usedQuestions = new Set();
            
            // Phase 1: Get one question from each hero (weighted)
            Object.values(heroesQuestions).forEach(hero => {
                const weightedPool = [];
                
                // Add core THREE times (weight 3)
                weightedPool.push(hero.core, hero.core, hero.core, hero.core);
                
                // Add each non-core once (weight 1)
                hero.questions.forEach(q => weightedPool.push(q));
                
                // Randomly select one
                const randomIndex = Math.floor(Math.random() * weightedPool.length);
                const selected = weightedPool[randomIndex];
                
                questions.push({
                    hero: hero.name,
                    question: selected,
                    color: hero.color,
                    focus: hero.focus
                });
                usedQuestions.add(selected);
            });
            
            // Phase 2: Select 3 more from remaining pool (weighted)
            const remainingPool = [];
            Object.values(heroesQuestions).forEach(hero => {
                if (!usedQuestions.has(hero.core)) {
                    // Add core THREE times (weight 3)
                    remainingPool.push({
                        hero: hero.name,
                        question: hero.core,
                        color: hero.color,
                        focus: hero.focus
                    });
                    remainingPool.push({
                        hero: hero.name,
                        question: hero.core,
                        color: hero.color,
                        focus: hero.focus
                    });
                    remainingPool.push({
                        hero: hero.name,
                        question: hero.core,
                        color: hero.color,
                        focus: hero.focus
                    });
                }
                hero.questions.forEach(q => {
                    if (!usedQuestions.has(q)) {
                        remainingPool.push({
                            hero: hero.name,
                            question: q,
                            color: hero.color,
                            focus: hero.focus
                        });
                    }
                });
            });
            
            // Select 3 more unique questions
            let availablePool = [...remainingPool];
            while (questions.length < 7 && availablePool.length > 0) {
                const randomIndex = Math.floor(Math.random() * availablePool.length);
                const selected = availablePool[randomIndex];
                
                if (!usedQuestions.has(selected.question)) {
                    questions.push(selected);
                    usedQuestions.add(selected.question);
                }
                
                availablePool = availablePool.filter(q => q.question !== selected.question);
            }
            
            return questions;
        }

        function toggleRating(qIdx, oIdx, r) {
            const key = `${qIdx}-${oIdx}`;
            if (state.responses[key] === r) {
                delete state.responses[key];
            } else {
                state.responses[key] = r;
            }
            render();
        }

        function toggleSkip(qIdx) {
            if (state.skipped.has(qIdx)) {
                state.skipped.delete(qIdx);
            } else {
                state.skipped.add(qIdx);
            }
            // Clear responses for this question if skipped
            state.options.forEach((_, oIdx) => {
                delete state.responses[`${qIdx}-${oIdx}`];
            });
            render();
        }

        function calculateScores() {
            const scores = state.options.map(() => ({ total: 0, breakdown: {} }));
            const activeIndices = state.selectedQuestions.map((_, idx) => idx).filter(idx => !state.skipped.has(idx));
            
            activeIndices.forEach(questionIndex => {
                state.options.forEach((option, optionIndex) => {
                    const key = `${questionIndex}-${optionIndex}`;
                    const response = state.responses[key] || 0;
                    scores[optionIndex].total += response;
                    
                    const question = state.selectedQuestions[questionIndex];
                    if (!scores[optionIndex].breakdown[question.hero]) {
                        scores[optionIndex].breakdown[question.hero] = 0;
                    }
                    scores[optionIndex].breakdown[question.hero] += response;
                });
            });

            return scores;
        }

        function resetMatrix() {
            state = {
                decision: '',
                options: ['', ''],
                currentStep: 0,
                responses: {},
                showResults: false,
                selectedQuestions: [],
                skipped: new Set()
            };
            render();
        }

        function getRatingLabel(rating) {
            const labels = {
                1: 'Not suitable',
                2: '',
                3: '',
                4: '',
                5: 'Highly suitable'
            };
            return labels[rating] || '';
        }

        function exportToCSV() {
            const scores = calculateScores();
            const activeCount = state.selectedQuestions.length - state.skipped.size;
            const maxScore = activeCount * 5;
            // Sanitize decision for filename (replace non-alphanum with _, truncate if too long)
            const sanitizedDecision = state.decision.replace(/[^a-zA-Z0-9\s]/g, '').trim().replace(/\s+/g, '_').substring(0, 50) || 'matrix';
            const filename = `hero-decision-${sanitizedDecision}.csv`;
            let csv = 'Question #,Hero,Status,Question Text';
            state.options.forEach((opt, i) => {
                csv += `,Option ${i+1} Rating (${opt})`;
            });
            csv += '\n';
            state.selectedQuestions.forEach((q, i) => {
                const isSkipped = state.skipped.has(i);
                csv += `${i+1},"${q.hero}","${isSkipped ? 'Skipped' : 'Active'}","${q.question.replace(/"/g, '""')}"`;
                state.options.forEach((opt, optIndex) => {
                    const rating = isSkipped ? '' : (state.responses[`${i}-${optIndex}`] || '');
                    csv += `,${rating}`;
                });
                csv += '\n';
            });
            csv += '\n,,,,Totals:\n';
            state.options.forEach((opt, i) => {
                const totalCols = new Array(3 + state.options.length).fill('').join(',');
                csv += `${totalCols},Option ${i+1} Total: ${scores[i].total}/${maxScore}`;
                csv += '\n';
            });

            const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
            const link = document.createElement('a');
            const url = URL.createObjectURL(blob);
            link.setAttribute('href', url);
            link.setAttribute('download', filename);
            link.style.visibility = 'hidden';
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        }

        async function exportSlideshowPDF() {
            const { jsPDF } = window.jspdf;
            const pdf = new jsPDF('p', 'mm', 'a4');
            let isFirst = true;
            const activeQuestions = state.selectedQuestions.filter((_, idx) => !state.skipped.has(idx));  // Only active
            const activeCount = activeQuestions.length;
            const maxPossible = activeCount * 5;
            const scores = calculateScores();
            const maxScore = Math.max(...scores.map(s => s.total));

            async function addPage(content) {
                const div = document.createElement('div');
                div.style.cssText = 'font-family: Arial, sans-serif; padding: 20px; width: 595px; min-height: 842px; background: white; box-sizing: border-box;';
                div.innerHTML = content;
                document.body.appendChild(div);

                const canvas = await html2canvas(div, { 
                    backgroundColor: '#ffffff',
                    scale: 1,
                    width: 595,
                    height: 842,
                    useCORS: true
                });
                const imgData = canvas.toDataURL('image/png');
                
                if (!isFirst) pdf.addPage();
                isFirst = false;
                
                const imgWidth = 210;
                const imgHeight = 297;
                pdf.addImage(imgData, 'PNG', 0, 0, imgWidth, imgHeight);
                
                document.body.removeChild(div);
            }

            // Merged Overview: Title + Decision + Options
            await addPage(`
                <div style="text-align:center;padding-top:50px">
                    <h1 style="font-size:36px;margin-bottom:20px">Hero Decision Matrix</h1>
                    <h2 style="font-size:24px;margin-bottom:20px">Decision Analysis: ${state.decision}</h2>
                    <p style="font-size:14px;margin-bottom:40px">${new Date().toLocaleDateString()} | Based on ${activeCount}/7 questions</p>
                    <h3 style="text-align:left;margin-bottom:20px;font-size:20px">Your Options</h3>
                    ${state.options.map((opt, i) => `
                        <p style="margin:15px 0;padding:15px;background:#f3f4f6;border-radius:8px">
                            <strong>Option ${i + 1}:</strong> ${opt}
                        </p>
                    `).join('')}
                </div>
            `);

            // Grouped Questions: 2-3 per page (dynamic chunks)
            const questionsPerPage = 3;  // Tweak this (2 for more space, 3 for tighter)
            for (let pageStart = 0; pageStart < activeQuestions.length; pageStart += questionsPerPage) {
                const pageQuestions = activeQuestions.slice(pageStart, pageStart + questionsPerPage);
                let pageContent = '<h1 style="text-align:center;margin-bottom:30px">Question Analysis</h1>';
                pageQuestions.forEach((q, globalIdx) => {  // globalIdx for responses key
                    const localIdx = activeQuestions.indexOf(q);  // Map to active index if needed, but use original i
                    const origIdx = state.selectedQuestions.indexOf(q);  // Original index for responses
                    pageContent += `
                        <div style="margin-bottom:25px;padding:15px;border:1px solid #ddd;border-radius:8px">
                            <h3 style="margin-bottom:10px;font-size:16px"><strong>${globalIdx + 1}. ${q.hero}:</strong> ${q.question}</h3>
                            <p style="font-size:12px;margin-bottom:10px">${q.focus}</p>
                            <table style="width:100%;border-collapse:collapse">
                                <tr style="background:#f9fafb">
                                    <th style="border:1px solid #ddd;padding:6px">Option</th>
                                    <th style="border:1px solid #ddd;padding:6px">Rating</th>
                                </tr>
                                ${state.options.map((opt, oi) => `
                                    <tr>
                                        <td style="border:1px solid #ddd;padding:6px">${opt}</td>
                                        <td style="border:1px solid #ddd;padding:6px;text-align:center">${state.responses[`${origIdx}-${oi}`] || ''}</td>
                                    </tr>
                                `).join('')}
                            </table>
                        </div>
                    `;
                });
                await addPage(pageContent);
            }

            // Final Results (unchanged, but note skips if any)
            const skippedCount = state.selectedQuestions.length - activeCount;
            await addPage(`
                <h1 style="text-align:center;margin-bottom:30px">Comprehensive Decision Analysis</h1>
                <h2 style="margin-top:20px;margin-bottom:10px">Final Results</h2>
                <table style="width:100%;border-collapse:collapse;margin-bottom:20px">
                    <tr style="background:#f9fafb">
                        <th style="border:1px solid #ddd;padding:8px">Option</th>
                        <th style="border:1px solid #ddd;padding:8px">Score</th>
                    </tr>
                    ${state.options.map((opt, i) => `
                        <tr>
                            <td style="border:1px solid #ddd;padding:8px">${opt}</td>
                            <td style="border:1px solid #ddd;padding:8px;text-align:center;font-weight:bold">${scores[i].total}/${maxPossible} ${scores[i].total === maxScore ? 'üèÜ' : ''}</td>
                        </tr>
                    `).join('')}
                </table>
                ${skippedCount > 0 ? `<p style="font-size:12px;color:gray;margin-bottom:10px">${skippedCount} question(s) skipped‚Äînot included in scoring.</p>` : ''}
                <h2 style="margin-top:20px;margin-bottom:10px">Questions You Analyzed</h2>
                <ul style="list-style-type:disc;padding-left:20px;font-size:12px;line-height:1.5;margin-bottom:20px">
                    ${state.selectedQuestions.map((q, i) => `
                        <li><strong>Q${i + 1} (${q.hero}):</strong> ${q.question} ${state.skipped.has(i) ? '(skipped)' : ''}</li>
                    `).join('')}
                </ul>
                <h2 style="margin-top:20px;margin-bottom:10px">Interpretation</h2>
                <ul style="list-style-type:disc;padding-left:20px;font-size:12px;line-height:1.5">
                    <li><strong>Highest scoring option:</strong> The option with the highest score (up to ${maxPossible}) reflects the strongest alignment with the wisdom traditions across spiritual, philosophical, logical, and rational lenses.</li>
                    <li><strong>Score gaps:</strong> Significant differences between option scores indicate varying levels of fit; review lower-scoring options for potential misalignment or blind spots.</li>
                    <li><strong>Low scores overall:</strong> If all totals are below ${Math.ceil(maxPossible / 2)}, consider refining options or exploring alternatives to better align with the wisdom criteria.</li>
                    <li><strong>Remember:</strong> These scores synthesize diverse perspectives, but your intuition should guide the final decision‚Äîwisdom transcends mere numbers.</li>
                </ul>
            `);

            // Updated filename: Sanitize decision (trim spaces, limit length, replace invalid chars)
            const sanitizedDecision = state.decision
                .replace(/[^a-zA-Z0-9\s-]/g, '')  // Keep letters, numbers, spaces, hyphens
                .trim()
                .replace(/\s+/g, '-')  // Replace spaces with hyphens
                .substring(0, 50)  // Cap at 50 chars
                .toLowerCase();
            const filename = `hero-decision-slideshow-${sanitizedDecision || 'analysis'}.pdf`;

            pdf.save(filename);
        }

        
        function renderSetup() {
            return `
                <div class="max-w-2xl mx-auto p-6">
                    <div class="text-center mb-8">
                        <h1 class="text-3xl font-bold text-gray-800 mb-2">Hero Decision Matrix</h1>
                        <p class="text-gray-600">7 focused questions to examine your decision</p>
                    </div>
                    <div class="bg-white p-6 rounded-lg border-2 border-gray-200">
                        <h2 class="text-xl font-bold text-gray-800 mb-4">What decision are you facing?</h2>
                        <textarea id="decisionInput" placeholder="Describe your decision..." class="w-full p-3 border border-gray-300 rounded-lg h-24">${state.decision}</textarea>
                        <h3 class="text-lg font-bold text-gray-800 mt-6 mb-4">What are your options?</h3>
                        <div class="space-y-3">
                            ${state.options.map((option, index) => `
                                <div class="flex items-center space-x-3">
                                    <span class="text-sm font-semibold text-gray-600">Option ${index + 1}:</span>
                                    <input type="text" value="${option}" placeholder="Enter option..." class="flex-1 p-2 border border-gray-300 rounded-lg option-input" data-index="${index}"/>
                                    ${state.options.length > 2 ? `<button onclick="removeOption(${index})" class="text-red-600">√ó</button>` : ''}
                                </div>
                            `).join('')}
                        </div>
                        ${state.options.length < 5 ? `<button onclick="addOption()" class="mt-3 text-blue-600">+ Add option</button>` : ''}
                        <button id="beginBtn" class="w-full mt-6 bg-blue-600 text-white py-3 rounded-lg font-semibold">Begin Analysis</button>
                    </div>
                </div>
            `;
        }

        function renderQuestions() {
            // Filter active (non-skipped) questions for display/counts
            const activeQuestions = state.selectedQuestions.filter((_, idx) => !state.skipped.has(idx));
            const totalRatingsNeeded = activeQuestions.length * state.options.length;
            const doneRatings = Object.keys(state.responses).filter(key => {
                const [qIdx] = key.split('-').map(Number);
                return !state.skipped.has(qIdx);
            }).length;

            return `
                <div class="max-w-5xl mx-auto p-6">
                    <div class="sticky top-0 z-10 bg-white/90 backdrop-blur border-b pb-3 mb-4">
                        <h1 class="text-2xl font-bold text-gray-800">Rate all options</h1>
                        <p class="text-sm text-gray-600">Decision: <b>${state.decision}</b></p>
                        <div class="mt-2 text-xs text-gray-500">Scroll down ‚Üí rate/skip each block ‚Üí hit "Finish" when ready (skips excluded from scores)</div>
                    </div>
                    <div class="space-y-8">
                        ${state.selectedQuestions.map((q, qIdx) => {
                            const isSkipped = state.skipped.has(qIdx);
                            return `
                                <section class="${q.color} p-5 rounded-lg border-2 ${isSkipped ? 'opacity-50' : ''}">
                                    <div class="flex justify-between items-start mb-4">
                                        <div>
                                            <h2 class="text-xl font-bold">${q.hero}</h2>
                                            <p class="text-xs opacity-80">${q.focus}</p>
                                            <h3 class="font-semibold mt-1">${qIdx + 1}. ${q.question}</h3>
                                        </div>
                                        <button onclick="toggleSkip(${qIdx})" class="bg-gray-200 hover:bg-gray-300 px-3 py-1 rounded text-sm ${isSkipped ? 'bg-red-200 text-red-800' : ''}">
                                            ${isSkipped ? 'Unskip' : 'Skip'}
                                        </button>
                                    </div>
                                    ${isSkipped ? 
                                        '<p class="text-sm text-gray-500 italic">Skipped‚Äîthis won\'t count in scores.</p>' :
                                        `
                                            <div class="grid gap-4 md:grid-cols-2 lg:grid-cols-3">
                                                ${(() => {
                                                    const numOptions = state.options.length;
                                                    const offset = qIdx % numOptions;
                                                    return state.options.map((opt, oIdx) => {
                                                        const displayIndex = (oIdx + offset) % numOptions;
                                                        const actualOption = state.options[displayIndex];
                                                        return `
                                                    <div class="bg-white p-3 rounded border">
                                                        <div class="text-sm font-medium mb-2">${actualOption}</div>
                                                        <div class="rating-container">
                                                            ${[1, 2, 3, 4, 5].map(r => `
                                                                <button class="rating-btn border hover:border-blue-400 ${state.responses[`${qIdx}-${displayIndex}`] === r ? 'selected' : ''}"
                                                                        onclick="toggleRating(${qIdx}, ${displayIndex}, ${r})">${r}</button>
                                                            `).join('')}
                                                        </div>
                                                    </div>
                                                        `;
                                                    }).join('');
                                                })()}
                                            </div>
                                        `
                                    }
                                </section>
                            `;
                        }).join('')}
                    </div>
                    <div class="sticky bottom-0 bg-white/90 backdrop-blur border-t mt-6 pt-3 flex justify-between items-center">
                        <button onclick="state.currentStep=0;render()" class="bg-gray-300 px-4 py-2 rounded">‚Üê Back to Setup</button>
                        <span id="progress" class="text-xs text-gray-500">${doneRatings}/${totalRatingsNeeded} ratings (of ${activeQuestions.length}/7 active questions)</span>
                        <button onclick="state.showResults=true;render()" class="bg-blue-600 text-white px-6 py-2 rounded">See Results</button>
                    </div>
                </div>
            `;
        }

        function updateDynamicElements() {
            const progressElement = document.getElementById('progress');
            if (progressElement) {
                const activeQuestions = state.selectedQuestions.filter((_, idx) => !state.skipped.has(idx));
                const total = activeQuestions.length * state.options.length;
                const done = Object.keys(state.responses).filter(key => {
                    const [qIdx] = key.split('-').map(Number);
                    return !state.skipped.has(qIdx);
                }).length;
                progressElement.textContent = `${done}/${total} ratings (of ${activeQuestions.length}/7 active questions)`;
            }

            document.querySelectorAll('.rating-btn').forEach(btn => {
                const match = btn.getAttribute('onclick')?.match(/toggleRating\((\d+),(\d+),(\d+)\)/);
                if (match) {
                    const [, q, o, r] = match;
                    const isSelected = state.responses[`${q}-${o}`] == r;
                    btn.classList.toggle('selected', isSelected);
                }
            });
        }

        function renderResults() {
            const scores = calculateScores();
            const activeCount = state.selectedQuestions.length - state.skipped.size;
            const maxPossible = activeCount * 5;
            const maxScore = Math.max(...scores.map(s => s.total));

            return `
                <div class="max-w-4xl mx-auto p-6">
                    <div class="text-center mb-8">
                        <h1 class="text-3xl font-bold text-gray-800 mb-2">Decision Analysis Results</h1>
                        <p class="text-gray-600 mb-4">Decision: <span class="font-semibold">${state.decision}</span> (based on ${activeCount}/7 questions)</p>
                        <div class="flex justify-center space-x-4 flex-wrap">
                            <button onclick="exportToCSV()" class="bg-green-600 text-white px-4 py-2 rounded-lg text-sm">Export CSV</button>
                            <button onclick="exportSlideshowPDF()" class="bg-blue-600 text-white px-4 py-2 rounded-lg text-sm">Slideshow PDF</button>
                            <button onclick="state.showResults=false;render()" class="bg-orange-600 text-white px-4 py-2 rounded-lg text-sm">Edit Ratings</button>
                            <button onclick="resetMatrix()" class="bg-gray-600 text-white px-4 py-2 rounded-lg text-sm">New Decision</button>
                        </div>
                    </div>
                    <div class="space-y-6">
                        ${state.options.map((option, index) => {
                            const score = scores[index];
                            const isTop = score.total === maxScore;
                            return `
                                <div class="${isTop ? 'bg-yellow-50 border-yellow-300' : 'bg-white border-gray-200'} p-6 rounded-lg border-2">
                                    <div class="flex items-center justify-between mb-4">
                                        <h3 class="text-xl font-bold text-gray-800">Option ${index + 1}: ${option}</h3>
                                        <span class="text-2xl font-bold text-gray-800">${score.total}/${maxPossible} ${isTop ? 'üèÜ' : ''}</span>
                                    </div>
                                    <div class="grid grid-cols-2 md:grid-cols-4 gap-4">
                                        ${Object.keys(score.breakdown).map(hero => `
                                            <div class="text-center p-3 bg-gray-100 rounded-lg">
                                                <p class="text-sm font-semibold text-gray-700">${hero}</p>
                                                <p class="text-lg font-bold text-gray-800">${score.breakdown[hero] || 0}</p>
                                            </div>
                                        `).join('')}
                                    </div>
                                </div>
                            `;
                        }).join('')}
                    </div>
                    <div class="mt-8 p-6 bg-white rounded-lg border-2 border-gray-200">
                        <h3 class="text-lg font-bold text-gray-800 mb-3">Questions You Analyzed</h3>
                        <div class="space-y-2 text-sm text-gray-600">
                            ${state.selectedQuestions.map((q, i) => `
                                <p><strong>Q${i+1} (${q.hero}):</strong> ${q.question} ${state.skipped.has(i) ? '(skipped)' : ''}</p>
                            `).join('')}
                        </div>
                        <h4 class="text-lg font-bold text-gray-800 mt-6 mb-3">Interpretation</h4>
                        <div class="space-y-2 text-sm text-gray-600">
                            <p><strong>Highest scoring option:</strong> This shows the strongest overall alignment with the wisdom traditions‚Äîyour intuitive sense of "suitability" across spiritual, philosophical, logical, and rational lenses.</p>
                            <p><strong>Score gaps:</strong> Wide differences highlight where options diverge in fit; revisit low-scoring areas for potential blind spots in alignment.</p>
                            <p><strong>Low scores overall:</strong> If totals are under ${Math.ceil(maxPossible / 2)}, some options may not align well‚Äîconsider refining them or exploring alternatives before committing.</p>
                            <p><strong>Remember:</strong> These suitability scores synthesize diverse perspectives, but trust your gut for the final call‚Äîwisdom isn't just numbers.</p>
                        </div>
                    </div>
                </div>
            `;
        }

        function render() {
            const app = document.getElementById('app');
            if (state.showResults) {
                app.innerHTML = renderResults();
            } else if (state.currentStep === 0) {
                app.innerHTML = renderSetup();
                setupEventListeners();
            } else {
                app.innerHTML = renderQuestions();
                updateDynamicElements();
            }
        }

        function setupEventListeners() {
            const decisionInput = document.getElementById('decisionInput');
            if (decisionInput) {
                decisionInput.addEventListener('input', (e) => {
                    state.decision = e.target.value;
                });
            }

            document.querySelectorAll('.option-input').forEach(input => {
                input.addEventListener('input', (e) => {
                    const index = parseInt(e.target.dataset.index);
                    updateOption(index, e.target.value);
                });
            });

            const beginBtn = document.getElementById('beginBtn');
            if (beginBtn) {
                beginBtn.addEventListener('click', () => {
                    if (state.decision.trim() && state.options.every(opt => opt.trim())) {
                        state.selectedQuestions = generateQuestions();
                        state.currentStep = 1;
                        render();
                    }
                });
            }
        }

        // Make functions globally available
        window.addOption = addOption;
        window.removeOption = removeOption;
        window.toggleRating = toggleRating;
        window.toggleSkip = toggleSkip;
        window.resetMatrix = resetMatrix;
        window.exportToCSV = exportToCSV;
        window.exportSlideshowPDF = exportSlideshowPDF;

        // Initial render
        document.addEventListener('DOMContentLoaded', () => {
            render();
        });
    </script>
</body>
</html>

